{
  "permissions": {
    "allow": [
      "WebSearch",
      "Bash(npx create-next-app:*)",
      "Bash(npx create-next-app@14:*)",
      "Bash(npm install:*)",
      "Bash(npx prisma generate:*)",
      "Bash(node --version:*)",
      "Bash(npx next build)",
      "Bash(brew list:*)",
      "Bash(pg_isready:*)",
      "Bash(curl:*)",
      "Bash(git commit -m \"$\\(cat <<''EOF''\nConstructAI â€” full application implementation\n\nAll 8 phases implemented:\n- Auth \\(NextAuth.js with credentials\\)\n- AI-powered service catalog onboarding\n- Project management with conversational estimates\n- Change orders with cost impact tracking\n- Invoice generation from chat\n- Customer portal \\(shareable, no-auth\\)\n- Audit trail & history\n- Voice input \\(Web Speech API\\)\n- PWA support for mobile install\n\nCo-Authored-By: Claude Opus 4.6 <noreply@anthropic.com>\nEOF\n\\)\")",
      "Bash(git push:*)",
      "Bash(git remote set-url:*)",
      "Bash(git add:*)",
      "Bash(git commit -m \"$\\(cat <<''EOF''\nFix Vercel build: add force-dynamic to all API routes and server pages\n\nPrevents Prisma from trying to connect to the database during the\nstatic build step. Also moves viewport/themeColor to proper export.\n\nCo-Authored-By: Claude Opus 4.6 <noreply@anthropic.com>\nEOF\n\\)\")",
      "Bash(git commit:*)",
      "Bash(npm run build:*)",
      "Bash(npx tsc:*)",
      "Bash(timeout 120 sh:*)",
      "Bash(npx next lint)",
      "Bash(cd:*)",
      "Bash(cd /Users/theodoregrossman/Desktop/Claude\\\\ Code\\\\ Projects/ConstructAI && npx prisma format:*)",
      "Bash(lsof -ti:3000)",
      "Bash(cd /Users/theodoregrossman/Desktop/Claude\\\\ Code\\\\ Projects/ConstructAI && npx prisma db pull:*)",
      "Bash(git checkout prisma/schema.prisma)",
      "Bash(grep:*)",
      "Bash(git revert:*)",
      "Bash(ls:*)",
      "Bash(cd /Users/theodoregrossman/Desktop/Claude\\\\ Code\\\\ Projects/ConstructAI && npx prisma db push:*)",
      "Bash(/Users/theodoregrossman/Desktop/Claude Code Projects/ConstructAI/src/app/api/projects/[projectId]/reconciliation/route.ts << 'ENDOFFILE'\nimport { NextRequest, NextResponse } from \"next/server\";\nimport { getServerSession } from \"next-auth\";\nimport { authOptions } from \"@/lib/auth\";\nimport { prisma } from \"@/lib/db\";\n\nexport const dynamic = 'force-dynamic';\n\ninterface ReconciliationLineItem {\n  id: string;\n  description: string;\n  parentId: string | null;\n  estimatedCost: number;\n  changeOrders: {\n    type: 'customer_requested' | 'unanticipated_issue';\n    impact: number;\n    changeOrderNumber: number;\n    title: string;\n  }[];\n  adjustedCost: number;\n  invoicedCost: number;\n  invoices: {\n    number: number;\n    status: string;\n    amount: number;\n  }[];\n  variance: number;\n  variancePercent: number;\n  children?: ReconciliationLineItem[];\n}\n\ninterface ReconciliationData {\n  projectName: string;\n  customerName: string;\n  originalEstimate: number;\n  customerRequestedChanges: number;\n  unanticipatedChanges: number;\n  estimatedCost: number;\n  maxBudget: number | null;\n  invoicedTotal: number;\n  paidTotal: number;\n  unpaidTotal: number;\n  remainingBudget: number;\n  variance: number;\n  variancePercent: number;\n  lineItems: ReconciliationLineItem[];\n}\n\nexport async function GET\\(\n  _req: NextRequest,\n  { params }: { params: { projectId: string } }\n\\) {\n  const session = await getServerSession\\(authOptions\\);\n  if \\(!session?.user\\) {\n    return NextResponse.json\\({ error: \"Unauthorized\" }, { status: 401 }\\);\n  }\n\n  const userId = \\(session.user as { id: string }\\).id;\n\n  const project = await prisma.project.findFirst\\({\n    where: { id: params.projectId, userId },\n    include: {\n      customer: true,\n      estimates: {\n        where: { status: \"approved\" },\n        include: { lineItems: { orderBy: { sortOrder: \"asc\" } } },\n        orderBy: { approvedAt: \"asc\" },\n        take: 1,\n      },\n      changeOrders: {\n        where: { status: \"approved\" },\n        include: { lineItems: true },\n        orderBy: { approvedAt: \"asc\" },\n      },\n      invoices: {\n        include: { lineItems: true },\n        orderBy: { createdAt: \"asc\" },\n      },\n    },\n  }\\);\n\n  if \\(!project\\) {\n    return NextResponse.json\\({ error: \"Project not found\" }, { status: 404 }\\);\n  }\n\n  const originalEstimate = project.estimates[0];\n  if \\(!originalEstimate\\) {\n    return NextResponse.json\\({ error: \"No approved estimate found\" }, { status: 404 }\\);\n  }\n\n  const lineItemMap = new Map<string, ReconciliationLineItem>\\(\\);\n\n  originalEstimate.lineItems.forEach\\(\\(item\\) => {\n    const estimatedCost = Number\\(item.total\\);\n    lineItemMap.set\\(item.id, {\n      id: item.id,\n      description: item.description,\n      parentId: item.parentId,\n      estimatedCost,\n      changeOrders: [],\n      adjustedCost: estimatedCost,\n      invoicedCost: 0,\n      invoices: [],\n      variance: 0,\n      variancePercent: 0,\n    }\\);\n  }\\);\n\n  project.changeOrders.forEach\\(\\(co\\) => {\n    co.lineItems.forEach\\(\\(item\\) => {\n      const matchingEstimateItem = originalEstimate.lineItems.find\\(\n        \\(ei\\) => ei.description === item.description\n      \\);\n      if \\(matchingEstimateItem\\) {\n        const reconItem = lineItemMap.get\\(matchingEstimateItem.id\\);\n        if \\(reconItem\\) {\n          const impact = Number\\(item.total\\);\n          reconItem.changeOrders.push\\({\n            type: co.type as 'customer_requested' | 'unanticipated_issue',\n            impact,\n            changeOrderNumber: co.number,\n            title: co.title,\n          }\\);\n          reconItem.adjustedCost += impact;\n        }\n      }\n    }\\);\n  }\\);\n\n  project.invoices.forEach\\(\\(invoice\\) => {\n    invoice.lineItems.forEach\\(\\(item\\) => {\n      if \\(item.estimateLineItemId\\) {\n        const reconItem = lineItemMap.get\\(item.estimateLineItemId\\);\n        if \\(reconItem\\) {\n          const amount = Number\\(item.total\\);\n          reconItem.invoicedCost += amount;\n          reconItem.invoices.push\\({\n            number: invoice.number,\n            status: invoice.status,\n            amount,\n          }\\);\n        }\n      }\n    }\\);\n  }\\);\n\n  lineItemMap.forEach\\(\\(item\\) => {\n    item.variance = item.adjustedCost - item.invoicedCost;\n    item.variancePercent = item.adjustedCost > 0 ? \\(item.variance / item.adjustedCost\\) * 100 : 0;\n  }\\);\n\n  const topLevelItems: ReconciliationLineItem[] = [];\n  const itemsArray = Array.from\\(lineItemMap.values\\(\\)\\);\n\n  itemsArray.forEach\\(\\(item\\) => {\n    if \\(!item.parentId\\) {\n      const children = itemsArray.filter\\(\\(i\\) => i.parentId === item.id\\);\n      if \\(children.length > 0\\) {\n        item.estimatedCost = children.reduce\\(\\(sum, c\\) => sum + c.estimatedCost, 0\\);\n        item.adjustedCost = children.reduce\\(\\(sum, c\\) => sum + c.adjustedCost, 0\\);\n        item.invoicedCost = children.reduce\\(\\(sum, c\\) => sum + c.invoicedCost, 0\\);\n        item.variance = item.adjustedCost - item.invoicedCost;\n        item.variancePercent = item.adjustedCost > 0 ? \\(item.variance / item.adjustedCost\\) * 100 : 0;\n        item.changeOrders = children.flatMap\\(\\(c\\) => c.changeOrders\\);\n        item.invoices = children.flatMap\\(\\(c\\) => c.invoices\\);\n        item.children = children;\n      }\n      topLevelItems.push\\(item\\);\n    }\n  }\\);\n\n  const originalEstimateTotal = Number\\(originalEstimate.total\\);\n  const customerRequestedChanges = project.changeOrders\n    .filter\\(\\(co\\) => co.type === 'customer_requested'\\)\n    .reduce\\(\\(sum, co\\) => sum + Number\\(co.costImpact\\), 0\\);\n  const unanticipatedChanges = project.changeOrders\n    .filter\\(\\(co\\) => co.type === 'unanticipated_issue'\\)\n    .reduce\\(\\(sum, co\\) => sum + Number\\(co.costImpact\\), 0\\);\n  const estimatedCost = originalEstimateTotal + customerRequestedChanges + unanticipatedChanges;\n  const invoicedTotal = project.invoices.reduce\\(\\(sum, inv\\) => sum + Number\\(inv.total\\), 0\\);\n  const paidTotal = project.invoices.filter\\(\\(inv\\) => inv.status === 'paid'\\).reduce\\(\\(sum, inv\\) => sum + Number\\(inv.total\\), 0\\);\n  const unpaidTotal = invoicedTotal - paidTotal;\n  const remainingBudget = estimatedCost - invoicedTotal;\n  const variance = estimatedCost - invoicedTotal;\n  const variancePercent = estimatedCost > 0 ? \\(variance / estimatedCost\\) * 100 : 0;\n\n  const data: ReconciliationData = {\n    projectName: project.name,\n    customerName: project.customer.name,\n    originalEstimate: originalEstimateTotal,\n    customerRequestedChanges,\n    unanticipatedChanges,\n    estimatedCost,\n    maxBudget: project.maxBudget ? Number\\(project.maxBudget\\) : null,\n    invoicedTotal,\n    paidTotal,\n    unpaidTotal,\n    remainingBudget,\n    variance,\n    variancePercent,\n    lineItems: topLevelItems,\n  };\n\n  return NextResponse.json\\(data\\);\n}\nENDOFFILE)",
      "Bash(/Users/theodoregrossman/Desktop/Claude Code Projects/ConstructAI/src/app/api/work-entries/route.ts << 'ENDOFFILE'\nimport { NextRequest, NextResponse } from \"next/server\";\nimport { getServerSession } from \"next-auth\";\nimport { authOptions } from \"@/lib/auth\";\nimport { prisma } from \"@/lib/db\";\n\nexport const dynamic = 'force-dynamic';\n\nexport async function POST\\(req: NextRequest\\) {\n  const session = await getServerSession\\(authOptions\\);\n  if \\(!session?.user\\) {\n    return NextResponse.json\\({ error: \"Unauthorized\" }, { status: 401 }\\);\n  }\n\n  const userId = \\(session.user as { id: string }\\).id;\n  const { projectId, workEntries } = await req.json\\(\\);\n\n  if \\(!projectId || !workEntries?.length\\) {\n    return NextResponse.json\\(\n      { error: \"projectId and workEntries are required\" },\n      { status: 400 }\n    \\);\n  }\n\n  // Verify project ownership\n  const project = await prisma.project.findFirst\\({\n    where: { id: projectId, userId },\n  }\\);\n\n  if \\(!project\\) {\n    return NextResponse.json\\({ error: \"Project not found\" }, { status: 404 }\\);\n  }\n\n  // Get or create draft invoice for this project\n  let invoice = await prisma.invoice.findFirst\\({\n    where: { projectId, status: \"draft\" },\n    include: { lineItems: true },\n  }\\);\n\n  if \\(!invoice\\) {\n    // Create new draft invoice\n    const lastInvoice = await prisma.invoice.findFirst\\({\n      where: { projectId },\n      orderBy: { number: \"desc\" },\n    }\\);\n\n    invoice = await prisma.invoice.create\\({\n      data: {\n        projectId,\n        number: \\(lastInvoice?.number || 0\\) + 1,\n        status: \"draft\",\n        subtotal: 0,\n        taxRate: 0,\n        taxAmount: 0,\n        total: 0,\n      },\n      include: { lineItems: true },\n    }\\);\n  }\n\n  // Add work entries to invoice\n  for \\(const entry of workEntries\\) {\n    const estimateLineItem = await prisma.estimateLineItem.findUnique\\({\n      where: { id: entry.estimateLineItemId },\n    }\\);\n\n    if \\(!estimateLineItem\\) {\n      continue; // Skip if estimate line item not found\n    }\n\n    // Check if this line item already has an invoice entry\n    const existingInvoiceItem = invoice.lineItems.find\\(\n      \\(item\\) => item.estimateLineItemId === entry.estimateLineItemId\n    \\);\n\n    if \\(existingInvoiceItem\\) {\n      // Update existing invoice line item\n      await prisma.invoiceLineItem.update\\({\n        where: { id: existingInvoiceItem.id },\n        data: {\n          timeHours: entry.actualTimeHours ? Number\\(entry.actualTimeHours\\) : null,\n          timeRate: entry.actualTimeRate ? Number\\(entry.actualTimeRate\\) : null,\n          timeCost: entry.actualTimeCost ? Number\\(entry.actualTimeCost\\) : null,\n          materialsCost: entry.actualMaterialsCost ? Number\\(entry.actualMaterialsCost\\) : null,\n          total: Number\\(entry.actualTotal\\),\n          notes: entry.notes || null,\n        },\n      }\\);\n    } else {\n      // Create new invoice line item\n      await prisma.invoiceLineItem.create\\({\n        data: {\n          invoiceId: invoice.id,\n          estimateLineItemId: entry.estimateLineItemId,\n          description: entry.description || estimateLineItem.description,\n          category: estimateLineItem.category,\n          parentId: estimateLineItem.parentId,\n          timeHours: entry.actualTimeHours ? Number\\(entry.actualTimeHours\\) : null,\n          timeRate: entry.actualTimeRate ? Number\\(entry.actualTimeRate\\) : null,\n          timeCost: entry.actualTimeCost ? Number\\(entry.actualTimeCost\\) : null,\n          materialsCost: entry.actualMaterialsCost ? Number\\(entry.actualMaterialsCost\\) : null,\n          total: Number\\(entry.actualTotal\\),\n          notes: entry.notes || null,\n          sortOrder: invoice.lineItems.length,\n        },\n      }\\);\n    }\n  }\n\n  // Recalculate invoice totals\n  const allLineItems = await prisma.invoiceLineItem.findMany\\({\n    where: { invoiceId: invoice.id },\n  }\\);\n\n  const subtotal = allLineItems.reduce\\(\\(sum, item\\) => sum + Number\\(item.total\\), 0\\);\n\n  // Get user's tax rate\n  const user = await prisma.user.findUnique\\({ where: { id: userId } }\\);\n  const taxRate = Number\\(user?.defaultTaxRate || 0\\);\n  const taxAmount = subtotal * taxRate;\n  const total = subtotal + taxAmount;\n\n  // Update invoice totals\n  await prisma.invoice.update\\({\n    where: { id: invoice.id },\n    data: {\n      subtotal,\n      taxRate,\n      taxAmount,\n      total,\n    },\n  }\\);\n\n  // Audit log\n  await prisma.auditLog.create\\({\n    data: {\n      projectId,\n      userId,\n      action: \"work_entry_created\",\n      entityType: \"invoice\",\n      entityId: invoice.id,\n      details: { workEntries },\n    },\n  }\\);\n\n  // Fetch updated invoice\n  const updatedInvoice = await prisma.invoice.findUnique\\({\n    where: { id: invoice.id },\n    include: { lineItems: true },\n  }\\);\n\n  return NextResponse.json\\(updatedInvoice, { status: 201 }\\);\n}\nENDOFFILE)",
      "Bash(cd /Users/theodoregrossman/Desktop/Claude\\\\ Code\\\\ Projects/ConstructAI && npx vercel logs:*)"
    ]
  }
}
