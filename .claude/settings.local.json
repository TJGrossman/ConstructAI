{
  "permissions": {
    "allow": [
      "WebSearch",
      "Bash(npx create-next-app:*)",
      "Bash(npx create-next-app@14:*)",
      "Bash(npm install:*)",
      "Bash(npx prisma generate:*)",
      "Bash(node --version:*)",
      "Bash(npx next build)",
      "Bash(brew list:*)",
      "Bash(pg_isready:*)",
      "Bash(curl:*)",
      "Bash(git commit -m \"$\\(cat <<''EOF''\nConstructAI â€” full application implementation\n\nAll 8 phases implemented:\n- Auth \\(NextAuth.js with credentials\\)\n- AI-powered service catalog onboarding\n- Project management with conversational estimates\n- Change orders with cost impact tracking\n- Invoice generation from chat\n- Customer portal \\(shareable, no-auth\\)\n- Audit trail & history\n- Voice input \\(Web Speech API\\)\n- PWA support for mobile install\n\nCo-Authored-By: Claude Opus 4.6 <noreply@anthropic.com>\nEOF\n\\)\")",
      "Bash(git push:*)",
      "Bash(git remote set-url:*)",
      "Bash(git add:*)",
      "Bash(git commit -m \"$\\(cat <<''EOF''\nFix Vercel build: add force-dynamic to all API routes and server pages\n\nPrevents Prisma from trying to connect to the database during the\nstatic build step. Also moves viewport/themeColor to proper export.\n\nCo-Authored-By: Claude Opus 4.6 <noreply@anthropic.com>\nEOF\n\\)\")",
      "Bash(git commit:*)",
      "Bash(npm run build:*)",
      "Bash(npx tsc:*)",
      "Bash(timeout 120 sh:*)",
      "Bash(npx next lint)",
      "Bash(cd:*)",
      "Bash(cd /Users/theodoregrossman/Desktop/Claude\\\\ Code\\\\ Projects/ConstructAI && npx prisma format:*)",
      "Bash(lsof -ti:3000)",
      "Bash(cd /Users/theodoregrossman/Desktop/Claude\\\\ Code\\\\ Projects/ConstructAI && npx prisma db pull:*)",
      "Bash(git checkout prisma/schema.prisma)",
      "Bash(grep:*)",
      "Bash(git revert:*)",
      "Bash(ls:*)",
      "Bash(cd /Users/theodoregrossman/Desktop/Claude\\\\ Code\\\\ Projects/ConstructAI && npx prisma db push:*)",
      "Bash(/Users/theodoregrossman/Desktop/Claude Code Projects/ConstructAI/src/app/api/projects/[projectId]/reconciliation/route.ts << 'ENDOFFILE'\nimport { NextRequest, NextResponse } from \"next/server\";\nimport { getServerSession } from \"next-auth\";\nimport { authOptions } from \"@/lib/auth\";\nimport { prisma } from \"@/lib/db\";\n\nexport const dynamic = 'force-dynamic';\n\ninterface ReconciliationLineItem {\n  id: string;\n  description: string;\n  parentId: string | null;\n  estimatedCost: number;\n  changeOrders: {\n    type: 'customer_requested' | 'unanticipated_issue';\n    impact: number;\n    changeOrderNumber: number;\n    title: string;\n  }[];\n  adjustedCost: number;\n  invoicedCost: number;\n  invoices: {\n    number: number;\n    status: string;\n    amount: number;\n  }[];\n  variance: number;\n  variancePercent: number;\n  children?: ReconciliationLineItem[];\n}\n\ninterface ReconciliationData {\n  projectName: string;\n  customerName: string;\n  originalEstimate: number;\n  customerRequestedChanges: number;\n  unanticipatedChanges: number;\n  estimatedCost: number;\n  maxBudget: number | null;\n  invoicedTotal: number;\n  paidTotal: number;\n  unpaidTotal: number;\n  remainingBudget: number;\n  variance: number;\n  variancePercent: number;\n  lineItems: ReconciliationLineItem[];\n}\n\nexport async function GET\\(\n  _req: NextRequest,\n  { params }: { params: { projectId: string } }\n\\) {\n  const session = await getServerSession\\(authOptions\\);\n  if \\(!session?.user\\) {\n    return NextResponse.json\\({ error: \"Unauthorized\" }, { status: 401 }\\);\n  }\n\n  const userId = \\(session.user as { id: string }\\).id;\n\n  const project = await prisma.project.findFirst\\({\n    where: { id: params.projectId, userId },\n    include: {\n      customer: true,\n      estimates: {\n        where: { status: \"approved\" },\n        include: { lineItems: { orderBy: { sortOrder: \"asc\" } } },\n        orderBy: { approvedAt: \"asc\" },\n        take: 1,\n      },\n      changeOrders: {\n        where: { status: \"approved\" },\n        include: { lineItems: true },\n        orderBy: { approvedAt: \"asc\" },\n      },\n      invoices: {\n        include: { lineItems: true },\n        orderBy: { createdAt: \"asc\" },\n      },\n    },\n  }\\);\n\n  if \\(!project\\) {\n    return NextResponse.json\\({ error: \"Project not found\" }, { status: 404 }\\);\n  }\n\n  const originalEstimate = project.estimates[0];\n  if \\(!originalEstimate\\) {\n    return NextResponse.json\\({ error: \"No approved estimate found\" }, { status: 404 }\\);\n  }\n\n  const lineItemMap = new Map<string, ReconciliationLineItem>\\(\\);\n\n  originalEstimate.lineItems.forEach\\(\\(item\\) => {\n    const estimatedCost = Number\\(item.total\\);\n    lineItemMap.set\\(item.id, {\n      id: item.id,\n      description: item.description,\n      parentId: item.parentId,\n      estimatedCost,\n      changeOrders: [],\n      adjustedCost: estimatedCost,\n      invoicedCost: 0,\n      invoices: [],\n      variance: 0,\n      variancePercent: 0,\n    }\\);\n  }\\);\n\n  project.changeOrders.forEach\\(\\(co\\) => {\n    co.lineItems.forEach\\(\\(item\\) => {\n      const matchingEstimateItem = originalEstimate.lineItems.find\\(\n        \\(ei\\) => ei.description === item.description\n      \\);\n      if \\(matchingEstimateItem\\) {\n        const reconItem = lineItemMap.get\\(matchingEstimateItem.id\\);\n        if \\(reconItem\\) {\n          const impact = Number\\(item.total\\);\n          reconItem.changeOrders.push\\({\n            type: co.type as 'customer_requested' | 'unanticipated_issue',\n            impact,\n            changeOrderNumber: co.number,\n            title: co.title,\n          }\\);\n          reconItem.adjustedCost += impact;\n        }\n      }\n    }\\);\n  }\\);\n\n  project.invoices.forEach\\(\\(invoice\\) => {\n    invoice.lineItems.forEach\\(\\(item\\) => {\n      if \\(item.estimateLineItemId\\) {\n        const reconItem = lineItemMap.get\\(item.estimateLineItemId\\);\n        if \\(reconItem\\) {\n          const amount = Number\\(item.total\\);\n          reconItem.invoicedCost += amount;\n          reconItem.invoices.push\\({\n            number: invoice.number,\n            status: invoice.status,\n            amount,\n          }\\);\n        }\n      }\n    }\\);\n  }\\);\n\n  lineItemMap.forEach\\(\\(item\\) => {\n    item.variance = item.adjustedCost - item.invoicedCost;\n    item.variancePercent = item.adjustedCost > 0 ? \\(item.variance / item.adjustedCost\\) * 100 : 0;\n  }\\);\n\n  const topLevelItems: ReconciliationLineItem[] = [];\n  const itemsArray = Array.from\\(lineItemMap.values\\(\\)\\);\n\n  itemsArray.forEach\\(\\(item\\) => {\n    if \\(!item.parentId\\) {\n      const children = itemsArray.filter\\(\\(i\\) => i.parentId === item.id\\);\n      if \\(children.length > 0\\) {\n        item.estimatedCost = children.reduce\\(\\(sum, c\\) => sum + c.estimatedCost, 0\\);\n        item.adjustedCost = children.reduce\\(\\(sum, c\\) => sum + c.adjustedCost, 0\\);\n        item.invoicedCost = children.reduce\\(\\(sum, c\\) => sum + c.invoicedCost, 0\\);\n        item.variance = item.adjustedCost - item.invoicedCost;\n        item.variancePercent = item.adjustedCost > 0 ? \\(item.variance / item.adjustedCost\\) * 100 : 0;\n        item.changeOrders = children.flatMap\\(\\(c\\) => c.changeOrders\\);\n        item.invoices = children.flatMap\\(\\(c\\) => c.invoices\\);\n        item.children = children;\n      }\n      topLevelItems.push\\(item\\);\n    }\n  }\\);\n\n  const originalEstimateTotal = Number\\(originalEstimate.total\\);\n  const customerRequestedChanges = project.changeOrders\n    .filter\\(\\(co\\) => co.type === 'customer_requested'\\)\n    .reduce\\(\\(sum, co\\) => sum + Number\\(co.costImpact\\), 0\\);\n  const unanticipatedChanges = project.changeOrders\n    .filter\\(\\(co\\) => co.type === 'unanticipated_issue'\\)\n    .reduce\\(\\(sum, co\\) => sum + Number\\(co.costImpact\\), 0\\);\n  const estimatedCost = originalEstimateTotal + customerRequestedChanges + unanticipatedChanges;\n  const invoicedTotal = project.invoices.reduce\\(\\(sum, inv\\) => sum + Number\\(inv.total\\), 0\\);\n  const paidTotal = project.invoices.filter\\(\\(inv\\) => inv.status === 'paid'\\).reduce\\(\\(sum, inv\\) => sum + Number\\(inv.total\\), 0\\);\n  const unpaidTotal = invoicedTotal - paidTotal;\n  const remainingBudget = estimatedCost - invoicedTotal;\n  const variance = estimatedCost - invoicedTotal;\n  const variancePercent = estimatedCost > 0 ? \\(variance / estimatedCost\\) * 100 : 0;\n\n  const data: ReconciliationData = {\n    projectName: project.name,\n    customerName: project.customer.name,\n    originalEstimate: originalEstimateTotal,\n    customerRequestedChanges,\n    unanticipatedChanges,\n    estimatedCost,\n    maxBudget: project.maxBudget ? Number\\(project.maxBudget\\) : null,\n    invoicedTotal,\n    paidTotal,\n    unpaidTotal,\n    remainingBudget,\n    variance,\n    variancePercent,\n    lineItems: topLevelItems,\n  };\n\n  return NextResponse.json\\(data\\);\n}\nENDOFFILE)"
    ]
  }
}
